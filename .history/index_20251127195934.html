<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥å¿«ä¹ - äº’åŠ¨ç²’å­é­”æ³•</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
        }

        .interactive-element {
            pointer-events: auto;
        }

        /* éšè—è§†é¢‘è¾“å…¥å…ƒç´  */
        .input_video {
            display: none;
        }

        /* ç»ç’ƒæ‹Ÿæ€å¡ç‰‡ */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
        }

        .fade-in {
            animation: fadeIn 1s ease-in forwards;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <!-- éšè—çš„è§†é¢‘æºï¼Œç”¨äºMediaPipeå¤„ç† -->
    <video class="input_video"></video>

    <!-- Canvas å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- å¯åŠ¨é®ç½© -->
    <div id="start-overlay">
        <div class="text-center max-w-md p-8 glass-panel">
            <h1 class="text-4xl font-bold mb-4 text-pink-400">âœ¨ ç²’å­é­”æ³•ç”Ÿæ—¥ä¼š âœ¨</h1>
            <p class="mb-6 text-gray-300">
                è¯·å…è®¸è®¿é—®<b>æ‘„åƒå¤´</b>ï¼ˆæ•æ‰æ‰‹åŠ¿ï¼‰å’Œ<b>éº¦å…‹é£</b>ï¼ˆå¹èœ¡çƒ›ï¼‰ã€‚<br>
                ä½“éªŒä¸“å±äºä½ çš„ 3D äº’åŠ¨æ—¶åˆ»ã€‚
            </p>
            <button id="start-btn" class="px-8 py-3 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full font-bold text-lg hover:scale-105 transition transform shadow-lg shadow-pink-500/50">
                å¼€å§‹ä½“éªŒ
            </button>
        </div>
    </div>

    <!-- ä¸» UI å±‚ -->
    <div id="ui-layer" style="display: none;">
        <!-- é¡¶éƒ¨æ  -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-4 interactive-element">
                <h2 class="text-xl font-bold text-pink-300 mb-1">Status</h2>
                <div id="status-text" class="text-sm text-white font-mono">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
            </div>
            
            <div class="glass-panel p-3 flex gap-4 interactive-element">
                <div class="flex flex-col items-center">
                    <label class="text-xs text-gray-400 mb-1">ç²’å­é¢œè‰²</label>
                    <input type="color" id="color-picker" value="#ff69b4" class="w-8 h-8 rounded cursor-pointer border-none bg-transparent">
                </div>
                <button id="fullscreen-btn" class="p-2 hover:bg-white/10 rounded transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                </button>
            </div>
        </div>

        <!-- ä¸­å¿ƒæç¤ºæ–‡å­— -->
        <div id="center-instruction" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none w-full">
            <h2 id="instruction-text" class="text-4xl md:text-6xl font-bold text-white drop-shadow-[0_0_10px_rgba(255,105,180,0.8)] transition-all duration-500">
                ğŸ‘‹ è¯·ä¸¾èµ·åŒæ‰‹
            </h2>
            <p id="sub-instruction" class="mt-4 text-xl text-pink-200 opacity-80">è®©é­”æ³•å¼€å§‹</p>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶ -->
        <div class="flex justify-center mb-8">
            <div id="camera-preview" class="w-32 h-24 glass-panel overflow-hidden relative interactive-element hidden md:block">
                 <!-- è¿™é‡Œçš„ canvas æ˜¯ mediapipe çš„è°ƒè¯•è§†å›¾ï¼Œæˆ‘ä»¬ç”¨JSåŠ¨æ€ç»˜åˆ¶ -->
                 <canvas id="output_canvas" width="160" height="120" class="w-full h-full object-cover"></canvas>
            </div>
        </div>
    </div>

    <script>
        /**
         * çŠ¶æ€æœºä¸å…¨å±€å˜é‡
         */
        const STATE = {
            IDLE: 0,        // ç­‰å¾…ä¸¾æ‰‹
            COUNTDOWN: 1,   // 3, 2, 1
            CAKE: 2,        // æ˜¾ç¤ºè›‹ç³•
            BLOWING: 3,     // ç­‰å¾…å¹æ°”
            CELEBRATION: 4  // åº†ç¥/å½©å¸¦
        };
        
        let currentState = STATE.IDLE;
        let particleSystem, scene, camera, renderer;
        let particlesData = [];
        const PARTICLE_COUNT = 4000;
        let baseColor = new THREE.Color(0xff69b4); // Hot pink
        let time = 0;
        
        // äº¤äº’å˜é‡
        let handDetected = false;
        let blowVolume = 0;
        let isBlowing = false;
        let mouse = new THREE.Vector2();
        
        // éŸ³é¢‘ä¸Šä¸‹æ–‡
        let audioContext;
        let analyser;
        let microphone;

        // Dom Elements
        const statusText = document.getElementById('status-text');
        const instructionText = document.getElementById('instruction-text');
        const subInstruction = document.getElementById('sub-instruction');
        const colorPicker = document.getElementById('color-picker');

        /**
         * 1. Three.js åœºæ™¯åˆå§‹åŒ–
         */
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // æ·»åŠ ä¸€ç‚¹ç¯å¢ƒé›¾
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticles();

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            colorPicker.addEventListener('input', (e) => {
                baseColor.set(e.target.value);
            });
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        }

        /**
         * 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘
         */
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            particlesData = [];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // åˆå§‹ä½ç½®ï¼šéšæœºåˆ†å¸ƒçš„çƒä½“
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 50;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                colors[i * 3] = baseColor.r;
                colors[i * 3 + 1] = baseColor.g;
                colors[i * 3 + 2] = baseColor.b;

                sizes[i] = Math.random() * 2;

                // å­˜å‚¨æ¯ä¸ªç²’å­çš„æ•°æ®ï¼Œç”¨äºåŠ¨ç”»æ’å€¼
                particlesData.push({
                    current: new THREE.Vector3(x, y, z),
                    target: new THREE.Vector3(x, y, z), // ç›®æ ‡ä½ç½®
                    velocity: new THREE.Vector3(0, 0, 0),
                    speed: 0.05 + Math.random() * 0.05,
                    isFlame: false // æ ‡è®°æ˜¯å¦ä¸ºèœ¡çƒ›ç«ç„°ç²’å­
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // è‡ªå®šä¹‰ Shader æè´¨ï¼Œä¸ºäº†æ›´å¥½çœ‹çš„ç²’å­æ•ˆæœ
            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                map: createCircleTexture(),
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const center = 16;
            const radius = 16;
            
            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        /**
         * 3. å½¢çŠ¶ç”Ÿæˆå™¨ (Text to Points & Geometry to Points)
         */
        
        // è¾…åŠ©ï¼šä»æ–‡å­—ç”Ÿæˆç‚¹é›†
        function getPointsFromText(text, size = 10) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;
            ctx.font = 'bold 100px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);

            const imageData = ctx.getImageData(0, 0, 200, 200);
            const points = [];
            
            // æ‰«æåƒç´ 
            for (let y = 0; y < 200; y += 4) {
                for (let x = 0; x < 200; x += 4) {
                    const alpha = imageData.data[(y * 200 + x) * 4 + 3];
                    if (alpha > 128) {
                        points.push(new THREE.Vector3(
                            (x - 100) / 4, // Scale down
                            -(y - 100) / 4, // Flip Y
                            0
                        ));
                    }
                }
            }
            return points;
        }

        // è¾…åŠ©ï¼šç”Ÿæˆè›‹ç³•å½¢çŠ¶
        function getCakePoints() {
            const points = [];
            const layers = [
                { r: 15, h: 5, y: -10 }, // Bottom layer
                { r: 10, h: 5, y: -5 }   // Top layer
            ];

            // è›‹ç³•ä½“
            for(let i=0; i<3000; i++) {
                const layer = Math.random() > 0.6 ? layers[1] : layers[0];
                const theta = Math.random() * Math.PI * 2;
                // å¡«å……åœ†æŸ±ä½“
                const r = Math.sqrt(Math.random()) * layer.r; 
                const y = layer.y + Math.random() * layer.h;
                
                points.push({
                    vec: new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)),
                    type: 'cake'
                });
            }

            // èœ¡çƒ› (ç»†åœ†æŸ±)
            for(let i=0; i<200; i++) {
                const r = Math.random() * 0.8;
                const theta = Math.random() * Math.PI * 2;
                const y = Math.random() * 6; // height 6
                points.push({
                    vec: new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)),
                    type: 'candle'
                });
            }

            // ç«ç„° (é¡¶éƒ¨èšé›†)
            for(let i=0; i<300; i++) {
                points.push({
                    vec: new THREE.Vector3(0, 7, 0), // Base of flame
                    type: 'flame'
                });
            }

            return points;
        }

        /**
         * 4. åŠ¨ç”»å¾ªç¯ä¸é€»è¾‘æ§åˆ¶
         */
        
        function setTargetShape(shapeType, param) {
            let targets = [];
            
            if (shapeType === 'text') {
                targets = getPointsFromText(param);
                // å°†æ–‡å­—ç‚¹åˆ†é…ç»™ç²’å­ï¼Œå¤šä½™çš„ç²’å­éšæœºåˆ†å¸ƒ
                particlesData.forEach((p, i) => {
                    p.isFlame = false;
                    if (i < targets.length) {
                        // æ”¾å¤§ä¸€ç‚¹æ–‡å­—
                        p.target.copy(targets[i]).multiplyScalar(2.5);
                    } else {
                        // èƒŒæ™¯ç²’å­
                        const theta = Math.random() * Math.PI * 2;
                        const r = 30 + Math.random() * 10;
                        p.target.set(r * Math.cos(theta), (Math.random()-0.5)*40, r * Math.sin(theta));
                    }
                });
            } else if (shapeType === 'cake') {
                const cakePoints = getCakePoints();
                particlesData.forEach((p, i) => {
                    if (i < cakePoints.length) {
                        p.target.copy(cakePoints[i].vec);
                        p.isFlame = (cakePoints[i].type === 'flame');
                    } else {
                        // å½¢æˆåº•åº§å…‰ç¯
                        const theta = Math.random() * Math.PI * 2;
                        const r = 20 + Math.random() * 20;
                        p.target.set(r * Math.cos(theta), -15, r * Math.sin(theta));
                        p.isFlame = false;
                    }
                });
            } else if (shapeType === 'explode') {
                particlesData.forEach(p => {
                    p.isFlame = false;
                    p.target.set(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 100
                    );
                    p.speed = 0.02; // æ…¢é€Ÿé£˜è½
                });
            }
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            time += 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particlesData[i];
                
                // 1. ç§»åŠ¨é€»è¾‘ (Lerp to target)
                // å¦‚æœæ˜¯åº†ç¥çŠ¶æ€ï¼Œæ·»åŠ é‡åŠ›å’Œé£åŠ›
                if (currentState === STATE.CELEBRATION) {
                    p.current.y -= p.speed * 2; // Gravity
                    p.current.x += Math.sin(time + i) * 0.1; // Wind
                    if (p.current.y < -40) p.current.y = 40; // Loop
                } else {
                    // æ ‡å‡†æ’å€¼è¿åŠ¨
                    let target = p.target.clone();

                    // ç«ç„°æŠ–åŠ¨æ•ˆæœ
                    if (p.isFlame && currentState === STATE.BLOWING) {
                        target.x += (Math.random() - 0.5) * 1.5;
                        target.y += Math.random() * 3; // å‘ä¸Šçªœ
                        target.z += (Math.random() - 0.5) * 1.5;
                        
                        // é¢œè‰²è®¾ä¸ºæ©™/çº¢
                        colors[i * 3] = 1.0;     // R
                        colors[i * 3 + 1] = 0.5; // G
                        colors[i * 3 + 2] = 0.0; // B
                    } else if (currentState === STATE.CAKE && p.isFlame) {
                        // ç†„ç­åçš„çƒŸé›¾
                        // ä¸åšç‰¹æ®Šå¤„ç†ï¼Œéšé£é£˜æˆ–å˜ç°
                    } else {
                        // æ™®é€šé¢œè‰²æ¢å¤ (Lerp to baseColor)
                        if (currentState !== STATE.CELEBRATION) { // åº†ç¥æ—¶ä¿æŒå¤šå½©
                            colors[i * 3] += (baseColor.r - colors[i * 3]) * 0.1;
                            colors[i * 3 + 1] += (baseColor.g - colors[i * 3 + 1]) * 0.1;
                            colors[i * 3 + 2] += (baseColor.b - colors[i * 3 + 2]) * 0.1;
                        }
                    }

                    // æ‰‹éƒ¨äº¤äº’ï¼šå¦‚æœæ£€æµ‹åˆ°æ‰‹ï¼Œç²’å­é¿å¼€æ‰‹çš„ä½ç½®
                    if (handDetected && currentState === STATE.IDLE) {
                        // ç®€å•çš„æ’æ–¥æ•ˆæœï¼Œå¦‚æœæœ‰æ‰‹éƒ¨åæ ‡ï¼ˆæ­¤å¤„ç®€åŒ–ï¼Œæœªä¼ å…¥å…·ä½“3Dåæ ‡ï¼Œä»…æ¼”ç¤ºé€»è¾‘ï¼‰
                        // å®é™…å¯ä»¥å°† mediapipe çš„ x,y æ˜ å°„åˆ° 3D ç©ºé—´è¿›è¡Œæ’æ–¥
                    }

                    p.current.lerp(target, 0.05);
                }

                positions[i * 3] = p.current.x;
                positions[i * 3 + 1] = p.current.y;
                positions[i * 3 + 2] = p.current.z;
                
                // éšæœºé—ªçƒ
                if (Math.random() > 0.95) {
                   // colors[i*3] = 1;
                   // colors[i*3+1] = 1;
                   // colors[i*3+2] = 1;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;

            // æ•´ä½“æ—‹è½¬
            if (currentState === STATE.CAKE || currentState === STATE.BLOWING) {
                particleSystem.rotation.y += 0.005;
            } else {
                particleSystem.rotation.y += 0.001;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            checkAudioBlow();
            renderer.render(scene, camera);
        }

        /**
         * 5. æµç¨‹æ§åˆ¶é€»è¾‘ (The Story)
         */
        
        function startCountdown() {
            if (currentState !== STATE.IDLE) return;
            currentState = STATE.COUNTDOWN;
            statusText.innerText = "å€’æ•°å¼€å§‹...";
            instructionText.innerText = "3";
            subInstruction.innerText = "å‡†å¤‡å¥½è®¸æ„¿";
            setTargetShape('text', "3");

            setTimeout(() => {
                instructionText.innerText = "2";
                setTargetShape('text', "2");
            }, 1500);

            setTimeout(() => {
                instructionText.innerText = "1";
                setTargetShape('text', "1");
            }, 3000);

            setTimeout(() => {
                startCakePhase();
            }, 4500);
        }

        function startCakePhase() {
            currentState = STATE.BLOWING; // æ˜¾ç¤ºè›‹ç³•å¹¶ç­‰å¾…å¹æ°”
            setTargetShape('cake');
            
            instructionText.innerText = "23å²å¥³ç”Ÿï¼Œç”Ÿæ—¥å¿«ä¹ï¼";
            instructionText.className = "text-3xl md:text-5xl font-bold text-pink-300 drop-shadow-lg";
            subInstruction.innerText = "è¯·é è¿‘éº¦å…‹é£ï¼Œç”¨åŠ›å¹ç­èœ¡çƒ› ğŸ‚ğŸ’¨";
            statusText.innerText = "æ£€æµ‹å¹æ°”ä¸­...";
            
            // æ’­æ”¾ç”Ÿæ—¥æ­Œçš„é€»è¾‘å¯ä»¥åœ¨è¿™é‡ŒåŠ  (Browser strict autoplay policy might block it)
        }

        function startCelebration() {
            currentState = STATE.CELEBRATION;
            statusText.innerText = "ğŸ‰ ç”Ÿæ—¥å¿«ä¹ï¼ ğŸ‰";
            instructionText.innerText = "æ„¿æœ›æˆçœŸï¼âœ¨";
            subInstruction.innerText = "";
            
            setTargetShape('explode');
            
            // éšæœºåŒ–é¢œè‰²ç”¨äºäº”å½©çº¸å±‘
            const colors = particleSystem.geometry.attributes.color.array;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                colors[i*3] = Math.random();
                colors[i*3+1] = Math.random();
                colors[i*3+2] = Math.random();
            }
        }

        /**
         * 6. Audio / Microphone (å¹æ°”æ£€æµ‹)
         */
        function initAudio() {
            if (!navigator.mediaDevices.getUserMedia) return;
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
                    analyser.fftSize = 256;
                })
                .catch(function(err) {
                    console.error('Mic error:', err);
                    statusText.innerText = "éº¦å…‹é£è®¿é—®å¤±è´¥ï¼Œæ— æ³•å¹èœ¡çƒ›";
                });
        }

        function checkAudioBlow() {
            if (currentState !== STATE.BLOWING || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            // è®¡ç®—å¹³å‡éŸ³é‡
            let sum = 0;
            // å¹æ°”é€šå¸¸ä¸»è¦æ˜¯ä½é¢‘å™ªéŸ³
            for(let i = 0; i < dataArray.length / 2; i++) {
                sum += dataArray[i];
            }
            const average = sum / (dataArray.length / 2);

            // é˜ˆå€¼æ£€æµ‹ (æ ¹æ®è®¾å¤‡æ•æ„Ÿåº¦å¯èƒ½éœ€è¦è°ƒæ•´ï¼Œ40-50é€šå¸¸æ˜¯è¿‘è·ç¦»å¹æ°”çš„å¼ºåº¦)
            if (average > 45) {
                blowVolume++;
                if (blowVolume > 10) { // æŒç»­æ£€æµ‹åˆ°ä¸€å°æ®µæ—¶é—´
                    startCelebration();
                }
            } else {
                blowVolume = Math.max(0, blowVolume - 1);
            }
        }

        /**
         * 7. MediaPipe Hands Setup
         */
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // ç»˜åˆ¶é¢„è§ˆï¼ˆå¯é€‰ï¼Œå¢å¼ºç”¨æˆ·ä¿¡å¿ƒï¼‰
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                
                // ç»˜åˆ¶éª¨æ¶
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#ff69b4', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});
                }
                
                // é€»è¾‘è§¦å‘ï¼šå¦‚æœæ£€æµ‹åˆ°æ‰‹ä¸”å¤„äºé—²ç½®çŠ¶æ€ï¼Œè§¦å‘å€’æ•°
                if (currentState === STATE.IDLE) {
                    statusText.innerText = "æ£€æµ‹åˆ°åŒæ‰‹ï¼é­”æ³•å¯åŠ¨...";
                    startCountdown();
                }
            } else {
                handDetected = false;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        /**
         * 8. UI & Helper Functions
         */
        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            
            // å¯åŠ¨éŸ³é¢‘
            initAudio();
            
            // å¯åŠ¨ Three.js
            initThree();
            animate();
            
            // å¯åŠ¨æ‘„åƒå¤´
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

    </script>
</body>
</html>