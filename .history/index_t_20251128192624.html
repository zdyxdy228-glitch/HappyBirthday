<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥å¿«ä¹ - äº’åŠ¨ç²’å­é­”æ³•</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
        }

        .interactive-element {
            pointer-events: auto;
        }

        /* éšè—è§†é¢‘è¾“å…¥å…ƒç´  */
        .input_video {
            display: none;
        }

        /* ç»ç’ƒæ‹Ÿæ€å¡ç‰‡ */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
        }

        .fade-in {
            animation: fadeIn 1s ease-in forwards;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        /* æƒŠå–œå¼¹çª—åŠ¨ç”» */
        .pop-in {
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.5) translateY(50px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
    </style>
</head>
<body>

    <!-- éšè—çš„è§†é¢‘æºï¼Œç”¨äºMediaPipeå¤„ç† -->
    <video class="input_video"></video>

    <!-- èƒŒæ™¯éŸ³ä¹ï¼šç”Ÿæ—¥å¿«ä¹æ­Œ (æ¥æºäº Wikimedia Commons, å…¬æœ‰é¢†åŸŸ) -->
    <!-- <audio id="birthday-song" src="https://upload.wikimedia.org/wikipedia/commons/6/6e/Happy_Birthday_to_You_-_Instrumental.ogg" loop></audio> -->
    <audio id="birthday-song" src="./src" loop></audio>

    <!-- Canvas å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- å¯åŠ¨é®ç½© -->
    <div id="start-overlay">
        <div class="text-center max-w-md p-8 glass-panel">
            <h1 class="text-4xl font-bold mb-4 text-pink-400">âœ¨ ç²’å­é­”æ³•ç”Ÿæ—¥ä¼š âœ¨</h1>
            <p class="mb-6 text-gray-300">
                è¯·å…è®¸è®¿é—®<b>æ‘„åƒå¤´</b>ï¼ˆæ•æ‰æ‰‹åŠ¿ï¼‰å’Œ<b>éº¦å…‹é£</b>ï¼ˆå¹èœ¡çƒ›ï¼‰ã€‚<br>
                ä½“éªŒä¸“å±äºä½ çš„ 3D äº’åŠ¨æ—¶åˆ»ã€‚
            </p>
            <button id="start-btn" class="px-8 py-3 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full font-bold text-lg hover:scale-105 transition transform shadow-lg shadow-pink-500/50">
                å¼€å§‹ä½“éªŒ
            </button>
        </div>
    </div>

    <!-- ä¸» UI å±‚ -->
    <div id="ui-layer" style="display: none;">
        <!-- é¡¶éƒ¨æ  -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-4 interactive-element">
                <h2 class="text-xl font-bold text-pink-300 mb-1">Status</h2>
                <div id="status-text" class="text-sm text-white font-mono">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
            </div>
            
            <div class="glass-panel p-3 flex gap-4 interactive-element">
                <div class="flex flex-col items-center">
                    <label class="text-xs text-gray-400 mb-1">ç²’å­é¢œè‰²</label>
                    <input type="color" id="color-picker" value="#ff69b4" class="w-8 h-8 rounded cursor-pointer border-none bg-transparent">
                </div>
                <button id="fullscreen-btn" class="p-2 hover:bg-white/10 rounded transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                </button>
            </div>
        </div>

        <!-- ä¸­å¿ƒæç¤ºæ–‡å­— -->
        <div id="center-instruction" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none w-full z-0">
            <h2 id="instruction-text" class="text-4xl md:text-6xl font-bold text-white drop-shadow-[0_0_10px_rgba(255,105,180,0.8)] transition-all duration-500">
                ğŸ‘‹ è¯·ä¸¾èµ·åŒæ‰‹
            </h2>
            <p id="sub-instruction" class="mt-4 text-xl text-pink-200 opacity-80">è®©é­”æ³•å¼€å§‹</p>
        </div>

        <!-- æƒŠå–œè¦†ç›–å±‚ (Celebration Surprise) -->
        <div id="surprise-layer" class="absolute inset-0 flex flex-col justify-center items-center z-20 hidden pointer-events-none">
            <!-- è§¦å‘æŒ‰é’® -->
            <button id="reveal-btn" class="interactive-element hidden px-10 py-5 bg-white text-pink-600 rounded-full font-bold text-2xl shadow-[0_0_30px_rgba(255,105,180,0.6)] hover:scale-110 transition transform animate-bounce">
                ğŸ ç‚¹å‡»æ­æ™“æƒŠå–œ
            </button>

            <!-- æƒŠå–œå†…å®¹å¡ç‰‡ -->
            <div id="surprise-content" class="interactive-element hidden max-w-md w-full mx-4 glass-panel p-6 transform transition-all duration-500 relative">
                <!-- è¿™é‡Œçš„ src å¯ä»¥æ›¿æ¢ä¸ºä½ æƒ³è¦çš„æˆªå›¾æˆ–ç…§ç‰‡ -->
                <div class="w-full h-64 bg-gray-800 rounded-lg mb-6 overflow-hidden border-2 border-pink-300 shadow-lg relative group">
                    <img src="https://images.unsplash.com/photo-1549465220-1a8b9238cd48?q=80&w=800&auto=format&fit=crop" class="w-full h-full object-cover transition duration-500 group-hover:scale-110" alt="Birthday Gift">
                    <div class="absolute bottom-0 left-0 w-full bg-black/60 text-white text-xs p-2 text-center opacity-70">
                        (è¯·åœ¨ä»£ç ä¸­æ›¿æ¢æ­¤å›¾ç‰‡ä¸ºæ‚¨å‡†å¤‡çš„æˆªå›¾)
                    </div>
                </div>
                
                <h3 class="text-2xl font-bold text-pink-300 mb-4 text-center">è‡´äº²çˆ±çš„ä½ </h3>
                <div class="text-white text-center leading-relaxed space-y-2 font-light">
                    <p>ç”Ÿæ—¥å¿«ä¹ï¼ğŸ‚</p>
                    <p>æ„¿ä½ åœ¨è¿™ç‰¹åˆ«çš„ä¸€å¤©é‡Œï¼Œ</p>
                    <p>æ‰€æœ‰çš„æ¢¦æƒ³éƒ½èƒ½åƒè¿™æ¼«å¤©ç¹æ˜Ÿä¸€æ ·é—ªè€€ã€‚</p>
                    <p>ä¿æŒçƒ­çˆ±ï¼Œå¥”èµ´å±±æµ·ï¼</p>
                    <p class="text-pink-400 font-bold mt-4">Happy 23rd Birthday!</p>
                </div>

                <button id="close-surprise-btn" class="absolute top-2 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶ -->
        <div class="flex justify-center mb-8">
            <div id="camera-preview" class="w-32 h-24 glass-panel overflow-hidden relative interactive-element hidden md:block">
                 <!-- è¿™é‡Œçš„ canvas æ˜¯ mediapipe çš„è°ƒè¯•è§†å›¾ï¼Œæˆ‘ä»¬ç”¨JSåŠ¨æ€ç»˜åˆ¶ -->
                 <canvas id="output_canvas" width="160" height="120" class="w-full h-full object-cover"></canvas>
            </div>
        </div>
    </div>

    <script>
        /**
         * çŠ¶æ€æœºä¸å…¨å±€å˜é‡
         */
        const STATE = {
            IDLE: 0,        // ç­‰å¾…ä¸¾æ‰‹
            COUNTDOWN: 1,   // 3, 2, 1
            CAKE: 2,        // æ˜¾ç¤ºè›‹ç³•
            BLOWING: 3,     // ç­‰å¾…å¹æ°” (æ˜¾ç¤ºè›‹ç³•å¹¶äº’åŠ¨)
            CELEBRATION: 4  // åº†ç¥/å½©å¸¦
        };
        
        let currentState = STATE.IDLE;
        let particleSystem, scene, camera, renderer;
        let particlesData = [];
        const PARTICLE_COUNT = 4500; 
        let baseColor = new THREE.Color(0xff69b4); // Hot pink
        let time = 0;
        
        // ç¼“å­˜å¯¹è±¡ï¼Œç”¨äºå­˜å‚¨é¢„è®¡ç®—çš„å½¢çŠ¶ç‚¹ä½
        const shapeCache = {};

        // äº¤äº’å˜é‡
        let handDetected = false;
        let blowVolume = 0;
        let isBlowing = false;
        let mouse = new THREE.Vector2();
        
        // éŸ³é¢‘ä¸Šä¸‹æ–‡
        let audioContext;
        let analyser;
        let microphone;

        // Dom Elements
        const statusText = document.getElementById('status-text');
        const instructionText = document.getElementById('instruction-text');
        const subInstruction = document.getElementById('sub-instruction');
        const colorPicker = document.getElementById('color-picker');

        // Surprise Elements (ä¿®å¤ï¼šè¡¥å……å®šä¹‰æƒŠå–œæŒ‰é’®ç›¸å…³DOMå…ƒç´ )
        const surpriseLayer = document.getElementById('surprise-layer');
        const revealBtn = document.getElementById('reveal-btn');
        const surpriseContent = document.getElementById('surprise-content');
        const closeSurpriseBtn = document.getElementById('close-surprise-btn');

        /**
         * 0. é¢„è®¡ç®—å½¢çŠ¶ (æ–°å¢ä¼˜åŒ–)
         */
        function preloadShapes() {
            // é¢„å…ˆè®¡ç®—å€’æ•°æ•°å­—çš„å½¢çŠ¶ç‚¹ä½ï¼Œé¿å…åŠ¨ç”»æ’­æ”¾æ—¶çš„CPUå¡é¡¿
            const nums = ['3', '2', '1'];
            nums.forEach(n => {
                shapeCache[n] = getPointsFromText(n);
            });
        }

        /**
         * 1. Three.js åœºæ™¯åˆå§‹åŒ–
         */
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // é¢„è®¡ç®—å½¢çŠ¶æ•°æ®
            preloadShapes();

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticles();

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            colorPicker.addEventListener('input', (e) => {
                baseColor.set(e.target.value);
            });
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        }

        /**
         * 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘
         */
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            particlesData = [];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // åˆå§‹ä½ç½®ï¼šéšæœºåˆ†å¸ƒçš„çƒä½“
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 50;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                colors[i * 3] = baseColor.r;
                colors[i * 3 + 1] = baseColor.g;
                colors[i * 3 + 2] = baseColor.b;

                sizes[i] = Math.random() * 2;

                // å­˜å‚¨æ¯ä¸ªç²’å­çš„æ•°æ®ï¼Œç”¨äºåŠ¨ç”»æ’å€¼
                particlesData.push({
                    current: new THREE.Vector3(x, y, z),
                    target: new THREE.Vector3(x, y, z), // ç›®æ ‡ä½ç½®
                    velocity: new THREE.Vector3(0, 0, 0),
                    speed: 0.05 + Math.random() * 0.05,
                    isFlame: false,
                    targetColor: baseColor.clone() // æ–°å¢ï¼šæ¯ä¸ªç²’å­ä¸“å±çš„ç›®æ ‡é¢œè‰²
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                map: createCircleTexture(),
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const center = 16;
            const radius = 16;
            
            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        /**
         * 3. å½¢çŠ¶ç”Ÿæˆå™¨ (Text to Points & Geometry to Points)
         */
        
        // è¾…åŠ©ï¼šä»æ–‡å­—ç”Ÿæˆç‚¹é›†
        function getPointsFromText(text, size = 10) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;
            ctx.font = 'bold 100px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);

            const imageData = ctx.getImageData(0, 0, 200, 200);
            const points = [];
            
            // æ‰«æåƒç´ 
            for (let y = 0; y < 200; y += 4) {
                for (let x = 0; x < 200; x += 4) {
                    const alpha = imageData.data[(y * 200 + x) * 4 + 3];
                    if (alpha > 128) {
                        points.push(new THREE.Vector3(
                            (x - 100) / 4, // Scale down
                            -(y - 100) / 4, // Flip Y
                            0
                        ));
                    }
                }
            }
            return points;
        }

        // è¾…åŠ©ï¼šç”Ÿæˆç²¾ç¾çš„è›‹ç³•å½¢çŠ¶
        function getCakePoints() {
            const points = [];
            
            // å®šä¹‰è›‹ç³•å±‚å‚æ•° (åŒå±‚è›‹ç³•)
            const layers = [
                { r: 14, h: 6, y: -10, color: new THREE.Color(0xFFB6C1) }, // åº•å±‚ï¼šæµ…ç²‰è‰²
                { r: 10, h: 5, y: -4,  color: new THREE.Color(0xFF69B4) }, // é¡¶å±‚ï¼šçƒ­ç²‰è‰²
            ];

            // 1. ç”Ÿæˆè›‹ç³•ä¸»ä½“ (ä½¿ç”¨åˆ†å±‚åœ†æŸ±ä½“)
            layers.forEach(layer => {
                // ä¾§é¢ (Shell) - ä½¿ç”¨æ›´å¤šç²’å­ç¡®ä¿çœ‹èµ·æ¥æ‰å®
                for(let i=0; i<800; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const h = Math.random() * layer.h;
                    // è®©ç²’å­ä¸»è¦é›†ä¸­åœ¨è¡¨é¢ï¼Œä½†ä¹Ÿæœ‰äº›è®¸åšåº¦
                    const r = layer.r * (0.95 + Math.random() * 0.05); 
                    
                    points.push({
                        vec: new THREE.Vector3(r * Math.cos(theta), layer.y + h, r * Math.sin(theta)),
                        type: 'cake',
                        color: layer.color
                    });
                }
                
                // é¡¶é¢ (Surface) - åƒå¥¶æ²¹ä¸€æ ·
                for(let i=0; i<400; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.random() * layer.r;
                    
                    points.push({
                        vec: new THREE.Vector3(r * Math.cos(theta), layer.y + layer.h, r * Math.sin(theta)),
                        type: 'cake',
                        color: new THREE.Color(0xFFFFFF) // ç™½è‰²å¥¶æ²¹é¡¶
                    });
                }

                // åº•éƒ¨è£…é¥°åœˆ (Decoration base)
                for(let i=0; i<150; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = layer.r + 0.5;
                    points.push({
                        vec: new THREE.Vector3(r * Math.cos(theta), layer.y, r * Math.sin(theta)),
                        type: 'cake',
                        color: new THREE.Color(0xFFFDD0) // å¥¶æ²¹è‰²è£…é¥°
                    });
                }
            });

            // 2. èœ¡çƒ› (å•æ ¹å¤§èœ¡çƒ›ï¼Œçº¢ç™½ç›¸é—´)
            const candleHeight = 8;
            const candleY = layers[1].y + layers[1].h;
            for(let i=0; i<300; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.8;
                const h = Math.random() * candleHeight;
                
                // åŸºç¡€ç™½è‰²
                let c = new THREE.Color(0xEEEEEE);
                
                // çº¢è‰²èºæ—‹çº¹è·¯
                // ä½¿ç”¨ç®€å•çš„æ­£å¼¦æ³¢é€»è¾‘æ¥æ¨¡æ‹Ÿèºæ—‹
                if (Math.sin(h * 2 + theta) > 0.5) {
                    c = new THREE.Color(0xFF0000);
                }

                points.push({
                    vec: new THREE.Vector3(r * Math.cos(theta), candleY + h, r * Math.sin(theta)),
                    type: 'candle',
                    color: c
                });
            }
            
            // 3. ç«ç„° (æ›´æœ‰å±‚æ¬¡æ„Ÿ)
            const flameBase = candleY + candleHeight;
            for(let i=0; i<400; i++) {
                // æ³ªæ»´å½¢/åœ†é”¥å½¢åˆ†å¸ƒ
                const u = Math.random();
                const theta = Math.random() * Math.PI * 2;
                
                // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
                const h = u * 5; 
                const r = (1 - u) * 1.5 * Math.sqrt(Math.random()); 

                // é¢œè‰²æ¸å˜ï¼šè“ -> æ©™ -> çº¢
                const color = new THREE.Color();
                if (u < 0.2) color.setHex(0x0000FF); // ç„°å¿ƒè“
                else if (u < 0.6) color.setHex(0xFFA500); // ä¸­é—´æ©™
                else color.setHex(0xFF4500); // ç„°å°–çº¢æ©™

                points.push({
                    vec: new THREE.Vector3(r * Math.cos(theta), flameBase + h, r * Math.sin(theta)),
                    type: 'flame',
                    color: color
                });
            }

            return points;
        }

        /**
         * 4. åŠ¨ç”»å¾ªç¯ä¸é€»è¾‘æ§åˆ¶
         */
        
        function setTargetShape(shapeType, param) {
            let targets = [];
            
            if (shapeType === 'text') {
                // ä¼˜å…ˆä»ç¼“å­˜ä¸­è¯»å–ï¼Œå¦‚æœæ²¡æœ‰åˆ™å®æ—¶è®¡ç®—ï¼ˆç†è®ºä¸Šå€’æ•°æ•°å­—éƒ½åœ¨ç¼“å­˜ä¸­ï¼‰
                if (shapeCache[param]) {
                    targets = shapeCache[param];
                } else {
                    targets = getPointsFromText(param);
                }

                // å°†æ–‡å­—ç‚¹åˆ†é…ç»™ç²’å­
                particlesData.forEach((p, i) => {
                    p.isFlame = false;
                    p.targetColor = baseColor; // é‡ç½®æ–‡å­—é¢œè‰²
                    
                    if (i < targets.length) {
                        p.target.copy(targets[i]).multiplyScalar(2.5);
                    } else {
                        // èƒŒæ™¯ç²’å­
                        const theta = Math.random() * Math.PI * 2;
                        const r = 30 + Math.random() * 10;
                        p.target.set(r * Math.cos(theta), (Math.random()-0.5)*40, r * Math.sin(theta));
                    }
                });
            } else if (shapeType === 'cake') {
                const cakePoints = getCakePoints();
                particlesData.forEach((p, i) => {
                    if (i < cakePoints.length) {
                        p.target.copy(cakePoints[i].vec);
                        p.isFlame = (cakePoints[i].type === 'flame');
                        
                        // è®¾ç½®è›‹ç³•ç‰¹æœ‰çš„é¢œè‰²
                        if (cakePoints[i].color) {
                            p.targetColor = cakePoints[i].color;
                        } else {
                            p.targetColor = baseColor;
                        }
                    } else {
                        // å½¢æˆåº•åº§å…‰ç¯ï¼Œé¢œè‰²åæš—
                        const theta = Math.random() * Math.PI * 2;
                        const r = 25 + Math.random() * 20;
                        p.target.set(r * Math.cos(theta), -15, r * Math.sin(theta));
                        p.isFlame = false;
                        p.targetColor = new THREE.Color(0x333333); // å˜æš—èƒŒæ™¯
                    }
                });
            } else if (shapeType === 'explode') {
                particlesData.forEach(p => {
                    p.isFlame = false;
                    p.target.set(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 100
                    );
                    p.speed = 0.02; // æ…¢é€Ÿé£˜è½
                    
                    // çˆ†ç‚¸æ—¶éšæœºå½©è‰²
                    p.targetColor = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
                });
            }
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            time += 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particlesData[i];
                
                // 1. ç§»åŠ¨é€»è¾‘
                if (currentState === STATE.CELEBRATION) {
                    p.current.y -= p.speed * 2; 
                    p.current.x += Math.sin(time + i) * 0.1;
                    if (p.current.y < -40) p.current.y = 40; 
                } else {
                    let target = p.target.clone();

                    // ç«ç„°åŠ¨æ€æ•ˆæœ
                    if (p.isFlame && currentState === STATE.BLOWING) {
                        // éšç€å¹æ°”æŒç»­æ—¶é—´(blowVolume)å¢åŠ ï¼Œç«ç„°æŠ–åŠ¨æ›´å‰§çƒˆï¼Œæ¨¡æ‹Ÿè¢«å¹çš„æ•ˆæœ
                        const jitter = 1 + (blowVolume * 0.1); 
                        
                        target.x += (Math.random() - 0.5) * 1.5 * jitter;
                        target.y += Math.random() * 3 * jitter; 
                        target.z += (Math.random() - 0.5) * 1.5 * jitter;
                    }

                    p.current.lerp(target, 0.05);
                }

                positions[i * 3] = p.current.x;
                positions[i * 3 + 1] = p.current.y;
                positions[i * 3 + 2] = p.current.z;
                
                // 2. é¢œè‰²é€»è¾‘
                // æ ¹æ®çŠ¶æ€å†³å®šç›®æ ‡é¢œè‰²
                let desiredColor = baseColor;
                
                if (currentState === STATE.BLOWING || currentState === STATE.CAKE || currentState === STATE.CELEBRATION) {
                    desiredColor = p.targetColor;
                }

                // é¢œè‰²æ’å€¼ (å¹³æ»‘è¿‡æ¸¡)
                if (currentState === STATE.BLOWING && p.isFlame) {
                    // ç«ç„°ç²’å­ä¿æŒå®ƒä»¬åŸæœ¬é²œè‰³çš„é¢œè‰²ï¼Œä¸è¿›è¡Œè¿‡åº¦æ’å€¼ä»¥å…å˜ç°
                    colors[i * 3] = p.targetColor.r;
                    colors[i * 3 + 1] = p.targetColor.g;
                    colors[i * 3 + 2] = p.targetColor.b;
                } else {
                    colors[i * 3] += (desiredColor.r - colors[i * 3]) * 0.05;
                    colors[i * 3 + 1] += (desiredColor.g - colors[i * 3 + 1]) * 0.05;
                    colors[i * 3 + 2] += (desiredColor.b - colors[i * 3 + 2]) * 0.05;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;

            // æ•´ä½“æ—‹è½¬
            if (currentState === STATE.CAKE || currentState === STATE.BLOWING) {
                particleSystem.rotation.y += 0.005;
            } else {
                particleSystem.rotation.y += 0.001;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            checkAudioBlow();
            renderer.render(scene, camera);
        }

        /**
         * 5. æµç¨‹æ§åˆ¶é€»è¾‘ (The Story)
         */
        
        function startCountdown() {
            if (currentState !== STATE.IDLE) return;
            currentState = STATE.COUNTDOWN;
            statusText.innerText = "å€’æ•°å¼€å§‹...";
            instructionText.innerText = "3";
            subInstruction.innerText = "å‡†å¤‡å¥½è®¸æ„¿";
            setTargetShape('text', "3");

            setTimeout(() => {
                instructionText.innerText = "2";
                setTargetShape('text', "2");
            }, 1500);

            setTimeout(() => {
                instructionText.innerText = "1";
                setTargetShape('text', "1");
            }, 3000);

            setTimeout(() => {
                startCakePhase();
            }, 4500);
        }

        function startCakePhase() {
            currentState = STATE.BLOWING; // æ˜¾ç¤ºè›‹ç³•å¹¶ç­‰å¾…å¹æ°”
            blowVolume = 0; // é‡ç½®å¹æ°”æ£€æµ‹è®¡æ•°å™¨
            setTargetShape('cake');
            
            instructionText.innerText = "23å²å¥³ç”Ÿï¼Œç”Ÿæ—¥å¿«ä¹ï¼";
            instructionText.className = "text-3xl md:text-5xl font-bold text-pink-300 drop-shadow-lg";
            subInstruction.innerText = "è¯·é è¿‘éº¦å…‹é£ï¼Œç”¨åŠ›å¹ç­èœ¡çƒ› ğŸ‚ğŸ’¨";
            statusText.innerText = "æ£€æµ‹å¹æ°”ä¸­...";
            
            // æ’­æ”¾ç”Ÿæ—¥æ­Œ
            const song = document.getElementById('birthday-song');
            song.volume = 0.5; // éŸ³é‡é€‚ä¸­
            song.play().catch(e => console.warn("æ— æ³•æ’­æ”¾èƒŒæ™¯éŸ³ä¹ï¼Œå¯èƒ½æ˜¯æµè§ˆå™¨ç­–ç•¥é™åˆ¶", e));
        }

        function startCelebration() {
            currentState = STATE.CELEBRATION;
            statusText.innerText = "ğŸ‰ ç”Ÿæ—¥å¿«ä¹ï¼ ğŸ‰";
            instructionText.innerText = "æ„¿æœ›æˆçœŸï¼âœ¨";
            subInstruction.innerText = "";
            
            setTargetShape('explode');

            // å»¶è¿Ÿæ˜¾ç¤ºæƒŠå–œæŒ‰é’®
            setTimeout(() => {
                surpriseLayer.classList.remove('hidden');
                surpriseLayer.classList.remove('pointer-events-none'); // å¯ç”¨ç‚¹å‡»
                revealBtn.classList.remove('hidden');
            }, 3000);
        }

        // Surprise Event Listeners
        revealBtn.addEventListener('click', () => {
            revealBtn.classList.add('hidden');
            surpriseContent.classList.remove('hidden');
            surpriseContent.classList.add('pop-in');
        });

        closeSurpriseBtn.addEventListener('click', () => {
            surpriseLayer.classList.add('hidden');
        });


        /**
         * 6. Audio / Microphone (å¹æ°”æ£€æµ‹)
         */
        function initAudio() {
            if (!navigator.mediaDevices.getUserMedia) return;
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
                    analyser.fftSize = 256;
                })
                .catch(function(err) {
                    console.error('Mic error:', err);
                    statusText.innerText = "éº¦å…‹é£è®¿é—®å¤±è´¥ï¼Œæ— æ³•å¹èœ¡çƒ›";
                });
        }

        function checkAudioBlow() {
            if (currentState !== STATE.BLOWING || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            // è®¡ç®—å¹³å‡éŸ³é‡
            let sum = 0;
            // å¹æ°”é€šå¸¸ä¸»è¦æ˜¯ä½é¢‘å™ªéŸ³
            for(let i = 0; i < dataArray.length / 2; i++) {
                sum += dataArray[i];
            }
            const average = sum / (dataArray.length / 2);

            // é˜ˆå€¼æ£€æµ‹ (éŸ³é‡ > 40)
            if (average > 40) {
                blowVolume++;
                // å¢åŠ æŒç»­æ—¶é—´è¦æ±‚ï¼šéœ€è¦æŒç»­æ£€æµ‹åˆ°çº¦ 100 å¸§ (çº¦ 1.5 - 2 ç§’)
                if (blowVolume > 100) { 
                    startCelebration();
                }
            } else {
                // å¦‚æœåœæ­¢å¹æ°”ï¼Œè¿›åº¦ç¼“æ…¢ä¸‹é™ï¼Œè€Œä¸æ˜¯ç«‹å³å½’é›¶
                blowVolume = Math.max(0, blowVolume - 0.5);
            }
        }

        /**
         * 7. MediaPipe Hands Setup
         */
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // ç»˜åˆ¶é¢„è§ˆï¼ˆå¯é€‰ï¼Œå¢å¼ºç”¨æˆ·ä¿¡å¿ƒï¼‰
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                
                // ç»˜åˆ¶éª¨æ¶
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#ff69b4', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});
                }
                
                // é€»è¾‘è§¦å‘ï¼šå¦‚æœæ£€æµ‹åˆ°æ‰‹ä¸”å¤„äºé—²ç½®çŠ¶æ€ï¼Œè§¦å‘å€’æ•°
                if (currentState === STATE.IDLE) {
                    statusText.innerText = "æ£€æµ‹åˆ°åŒæ‰‹ï¼é­”æ³•å¯åŠ¨...";
                    startCountdown();
                }
            } else {
                handDetected = false;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        /**
         * 8. UI & Helper Functions
         */
        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            
            // é¢„åŠ è½½éŸ³ä¹ (iOS/Android éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½æ’­æ”¾éŸ³é¢‘)
            const song = document.getElementById('birthday-song');
            song.load();

            // å¯åŠ¨éŸ³é¢‘
            initAudio();
            
            // å¯åŠ¨ Three.js
            initThree();
            animate();
            
            // å¯åŠ¨æ‘„åƒå¤´
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

    </script>
</body>
</html>