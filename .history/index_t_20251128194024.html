<!-- START OF FILE index.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥å¿«ä¹ - äº’åŠ¨ç²’å­é­”æ³• v2.0</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
            box-sizing: border-box;
        }

        .interactive-element {
            pointer-events: auto;
        }

        .input_video { display: none; }

        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
            transition: all 0.3s ease;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        /* å¹æ°”è¿›åº¦æ¡æ ·å¼ */
        #blow-meter-container {
            position: absolute;
            bottom: 20%; 
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s;
            display: flex;
            align-items: center;
            padding: 2px;
        }

        #blow-meter-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            border-radius: 18px;
            transition: width 0.1s linear;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.8);
        }
        
        #blow-label {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: rgba(255,255,255,0.9);
            text-shadow: 0 1px 2px black;
        }

        /* æƒŠå–œå¼¹çª—åŠ¨ç”» */
        .pop-in {
            animation: popIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.8) translateY(20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        /* å‘¼å¸ç¯åŠ¨ç”» */
        .animate-breath {
            animation: breath 2s infinite ease-in-out;
        }
        @keyframes breath {
            0%, 100% { box-shadow: 0 0 20px rgba(255,105,180,0.4); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(255,105,180,0.8); transform: scale(1.05); }
        }
    </style>
</head>
<body>

    <!-- èƒŒæ™¯éŸ³ä¹ (è‡ªåŠ¨å¾ªç¯) -->
    <audio id="bgm" loop>
        <!-- è¿™é‡Œä½¿ç”¨ä¸€ä¸ªé€šç”¨çš„éŸ³ä¹å¤–é“¾ï¼Œå»ºè®®æ›¿æ¢ä¸ºæ‚¨è‡ªå·±çš„ mp3 æ–‡ä»¶ -->
        <source src="./src/happy-birthday-155461.mp3" type="audio/mpeg">
    </audio>

    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <!-- å¯åŠ¨é¡µé¢ -->
    <div id="start-overlay">
        <div class="text-center max-w-md p-8 glass-panel mx-4">
            <h1 class="text-5xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-pink-400 to-purple-400">
                ğŸ‚ ç”Ÿæ—¥é­”æ³•
            </h1>
            <div class="space-y-4 text-gray-300 text-lg mb-8">
                <p>ğŸ‘‹ <b>ä¸¾èµ·åŒæ‰‹</b> å¬å”¤è›‹ç³•</p>
                <p>ğŸ¤ <b>å¯¹ç€éº¦å…‹é£å¹æ°”</b> ç†„ç­èœ¡çƒ›</p>
            </div>
            <button id="start-btn" class="px-10 py-4 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full font-bold text-xl hover:scale-105 transition transform shadow-lg shadow-pink-500/50 text-white animate-breath">
                å¼€å¯ä½“éªŒ
            </button>
            <p class="mt-4 text-xs text-gray-500">* éœ€è¦æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™</p>
        </div>
    </div>

    <!-- å¹æ°”è¿›åº¦æ¡ -->
    <div id="blow-meter-container" class="z-20">
        <div id="blow-meter-bar"></div>
        <div id="blow-label">ğŸ’¨ è¯·æŒç»­ç”¨åŠ›å¹æ°”...</div>
    </div>

    <!-- ä¸» UI å±‚ -->
    <div id="ui-layer" style="display: none;">
        <!-- é¡¶éƒ¨ -->
        <div class="flex justify-between items-start w-full">
            <div class="glass-panel px-4 py-2 interactive-element">
                <div id="status-dot" class="inline-block w-3 h-3 rounded-full bg-red-500 mr-2"></div>
                <span id="status-text" class="text-sm font-mono">ç­‰å¾…æ‰‹åŠ¿...</span>
            </div>
            
            <button id="music-btn" class="interactive-element p-3 glass-panel hover:bg-white/20 transition rounded-full">
                ğŸµ
            </button>
        </div>

        <!-- ä¸­å¿ƒæ–‡å­— -->
        <div id="center-instruction" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none w-full z-0">
            <h2 id="instruction-text" class="text-5xl md:text-7xl font-bold text-white drop-shadow-[0_0_15px_rgba(255,105,180,0.8)] transition-all duration-700">
                ğŸ‘‹ ä¸¾èµ·åŒæ‰‹
            </h2>
            <p id="sub-instruction" class="mt-4 text-2xl text-pink-200 opacity-90 font-light tracking-widest">è®©é­”æ³•å‘ç”Ÿ</p>
        </div>

        <!-- æƒŠå–œäº¤äº’å±‚ -->
        <div id="surprise-layer" class="absolute inset-0 flex flex-col justify-center items-center z-30 hidden pointer-events-none">
            
            <!-- è§¦å‘æŒ‰é’® (å±…ä¸­) -->
            <button id="reveal-btn" class="interactive-element px-12 py-6 bg-white text-pink-600 rounded-full font-bold text-3xl shadow-[0_0_50px_rgba(255,105,180,0.8)] hover:scale-110 transition-transform duration-300 animate-breath z-40">
                ğŸ ç‚¹å‡»æ‹†å¼€ç¤¼ç‰©
            </button>

            <!-- æƒŠå–œå¡ç‰‡ (ç‚¹å‡»æŒ‰é’®åæ˜¾ç¤º) -->
            <div id="surprise-content" class="interactive-element hidden max-w-sm md:max-w-lg w-full glass-panel p-1 bg-gradient-to-br from-pink-500/30 to-purple-500/30 border-t border-l border-white/40 shadow-2xl z-50">
                <div class="bg-black/40 rounded-xl p-6 md:p-8 backdrop-blur-xl">
                    <!-- å›¾ç‰‡åŒºåŸŸ -->
                    <div class="w-full h-64 bg-gray-900 rounded-lg mb-6 overflow-hidden relative group border border-white/10">
                        <img src="https://images.unsplash.com/photo-1513151241214-ca63c96898ec?q=80&w=1000&auto=format&fit=crop" 
                             class="w-full h-full object-cover transition duration-700 group-hover:scale-110 group-hover:rotate-1" 
                             alt="Birthday">
                        <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent flex items-end justify-center p-4">
                            <span class="text-white/80 text-sm font-light">âœ¨ Best Wishes for You âœ¨</span>
                        </div>
                    </div>
                    
                    <h3 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 to-white mb-4 text-center">
                        ç”Ÿæ—¥å¿«ä¹ï¼
                    </h3>
                    
                    <div class="text-center space-y-3 text-gray-200 font-light leading-relaxed">
                        <p>å²å²å¹´å¹´ï¼Œä¸‡å–œä¸‡èˆ¬å®œã€‚</p>
                        <p>æ„¿ä½ çš„ç”Ÿæ´»å¦‚è¿™ç²’å­èˆ¬ç’€ç’¨ï¼Œ</p>
                        <p>è‡ªç”±ã€çƒ­çƒˆã€å……æ»¡å…‰èŠ’ã€‚</p>
                    </div>

                    <div class="mt-8 flex justify-center">
                        <button id="close-surprise-btn" class="px-6 py-2 rounded-full border border-pink-500/50 text-pink-300 hover:bg-pink-500/20 transition text-sm">
                            æ”¶èµ·å¡ç‰‡
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- è°ƒè¯•è§†å›¾ (ä»…åœ¨å¤§å±æ˜¾ç¤º) -->
        <div class="absolute bottom-4 left-4 hidden md:block opacity-50 hover:opacity-100 transition">
            <div class="w-32 h-24 glass-panel overflow-hidden">
                 <canvas id="output_canvas" width="160" height="120" class="w-full h-full object-cover"></canvas>
            </div>
        </div>
    </div>

    <script>
        /** --- å…¨å±€é…ç½® --- */
        const CONFIG = {
            particleCount: 5000,
            color: 0xff69b4, // Hot Pink
            blowThreshold: 30, // é™ä½é˜ˆå€¼ï¼Œæ›´å®¹æ˜“è§¦å‘
            blowMaxDuration: 100 // éœ€è¦æŒç»­å¹æ°”çš„å¸§æ•° (çº¦1.5-2ç§’)
        };

        const STATE = {
            IDLE: 0,
            COUNTDOWN: 1,
            CAKE: 2,
            BLOWING: 3,
            CELEBRATION: 4
        };

        let currentState = STATE.IDLE;
        let particlesData = [];
        let scene, camera, renderer, particleSystem;
        let time = 0;
        
        // å¹æ°”ç›¸å…³
        let blowProgress = 0; // 0 åˆ° 100
        let isBlowing = false;
        
        // éŸ³é¢‘
        let audioContext, analyser, microphone;
        const bgm = document.getElementById('bgm');

        // DOM å…ƒç´ 
        const uiLayer = document.getElementById('ui-layer');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const instructionText = document.getElementById('instruction-text');
        const subInstruction = document.getElementById('sub-instruction');
        const blowMeterContainer = document.getElementById('blow-meter-container');
        const blowMeterBar = document.getElementById('blow-meter-bar');
        const surpriseLayer = document.getElementById('surprise-layer');
        const revealBtn = document.getElementById('reveal-btn');
        const surpriseContent = document.getElementById('surprise-content');

        /* --- 1. Three.js æ ¸å¿ƒé€»è¾‘ --- */
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 45;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½ä¼˜åŒ–
            container.appendChild(renderer.domElement);

            createParticles();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);

            particlesData = [];
            const colorObj = new THREE.Color(CONFIG.color);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const x = (Math.random() - 0.5) * 150;
                const y = (Math.random() - 0.5) * 150;
                const z = (Math.random() - 0.5) * 100;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;

                sizes[i] = Math.random() * 2;

                particlesData.push({
                    current: new THREE.Vector3(x, y, z),
                    target: new THREE.Vector3(x, y, z),
                    baseTarget: new THREE.Vector3(x, y, z), // è®°å½•åŸå§‹ç›®æ ‡ä½ç½®
                    velocity: new THREE.Vector3(0, 0, 0),
                    speed: 0.02 + Math.random() * 0.04,
                    type: 'bg', // bg, cake, candle, flame
                    targetColor: colorObj.clone(),
                    noiseOffset: Math.random() * 100
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1.0,
                vertexColors: true,
                map: getCircleTexture(),
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function getCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        /* --- 2. å½¢çŠ¶ç”Ÿæˆé€»è¾‘ --- */
        function getShapePoints(type, text) {
            const points = [];
            
            if (type === 'text') {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200; canvas.height = 200;
                ctx.font = 'bold 120px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 100, 100);
                const data = ctx.getImageData(0,0,200,200).data;
                
                for(let y=0; y<200; y+=3) {
                    for(let x=0; x<200; x+=3) {
                        if(data[(y*200+x)*4+3] > 128) {
                            points.push({
                                vec: new THREE.Vector3((x-100)/3, -(y-100)/3, 0).multiplyScalar(2),
                                type: 'text',
                                color: new THREE.Color(0xffffff)
                            });
                        }
                    }
                }
            } 
            else if (type === 'cake') {
                // ç®€å•çš„ä¸¤å±‚è›‹ç³• + èœ¡çƒ›
                const layers = [
                    {y:-12, r:16, h:6, c:0xFFB7C5}, // åº•å±‚
                    {y:-6, r:11, h:5, c:0xFF69B4}   // é¡¶å±‚
                ];
                
                // è›‹ç³•ä½“
                layers.forEach(l => {
                    for(let i=0; i<800; i++) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = Math.random() * l.r;
                        const h = Math.random() * l.h;
                        // ä¾§é¢å¤šä¸€ç‚¹ç²’å­
                        const finalR = (Math.random() > 0.3) ? l.r : r;
                        points.push({
                            vec: new THREE.Vector3(finalR*Math.cos(theta), l.y+h, finalR*Math.sin(theta)),
                            type: 'cake',
                            color: new THREE.Color(l.c)
                        });
                    }
                });

                // èœ¡çƒ› (ä¸­é—´ä¸€æ ¹)
                for(let i=0; i<200; i++) {
                    const h = Math.random() * 8;
                    const r = Math.random() * 0.8;
                    const theta = Math.random() * Math.PI * 2;
                    points.push({
                        vec: new THREE.Vector3(r*Math.cos(theta), -1+h, r*Math.sin(theta)),
                        type: 'candle',
                        color: (Math.sin(h*3)>0) ? new THREE.Color(0xff0000) : new THREE.Color(0xffffff)
                    });
                }

                // ç«ç„°
                for(let i=0; i<300; i++) {
                    const u = Math.random();
                    const h = u * 5; 
                    const r = (1-u) * 1.5 * Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    
                    let flameC = new THREE.Color(0xffaa00);
                    if(u<0.3) flameC.setHex(0x0000ff); // è“èŠ¯
                    else if(u>0.7) flameC.setHex(0xff0000); // çº¢é¡¶

                    points.push({
                        vec: new THREE.Vector3(r*Math.cos(theta), 7+h, r*Math.sin(theta)),
                        type: 'flame',
                        color: flameC
                    });
                }
            }
            return points;
        }

        function transitionTo(shapeType, param) {
            const targets = getShapePoints(shapeType, param);
            
            particlesData.forEach((p, i) => {
                if (i < targets.length) {
                    p.baseTarget.copy(targets[i].vec);
                    p.target.copy(targets[i].vec);
                    p.type = targets[i].type;
                    p.targetColor = targets[i].color;
                } else {
                    // å¤šä½™çš„ç²’å­ä½œä¸ºèƒŒæ™¯æ°›å›´
                    const angle = Math.random() * Math.PI * 2;
                    const r = 30 + Math.random() * 30;
                    p.baseTarget.set(r*Math.cos(angle), (Math.random()-0.5)*60, r*Math.sin(angle));
                    p.target.copy(p.baseTarget);
                    p.type = 'bg';
                    p.targetColor = new THREE.Color(0x333333); // æš—æ·¡èƒŒæ™¯
                }
            });
        }

        /* --- 3. åŠ¨ç”»å¾ªç¯ä¸ç‰©ç†åé¦ˆ --- */
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            time += 0.02;

            // å¹æ°”å½±å“åŠ› (0.0 - 1.0)
            const blowInfluence = blowProgress / 100;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = particlesData[i];
                let target = p.target.clone();

                // äº’åŠ¨é€»è¾‘
                if (p.type === 'flame' && currentState === STATE.BLOWING) {
                    // ç«ç„°æŠ–åŠ¨
                    const noise = Math.sin(time * 5 + p.noiseOffset) * 0.5;
                    target.x += noise;
                    
                    // å…³é”®ï¼šå¹æ°”æ—¶ï¼Œç«ç„°å‘ä¸Šé£å¹¶å˜å°ï¼ˆæ¨¡æ‹Ÿç†„ç­ï¼‰
                    if (blowInfluence > 0.1) {
                        // å‘ä¸Šé£æ•£
                        target.y += blowInfluence * 15; 
                        target.x += (Math.random()-0.5) * blowInfluence * 5;
                        
                        // å˜è‰²ä¸ºçƒŸé›¾ç°
                        const smokeColor = new THREE.Color(0x555555);
                        p.targetColor.lerp(smokeColor, 0.1);
                    }
                }

                // ç§»åŠ¨æ’å€¼
                p.current.lerp(target, 0.08);

                // èµ‹å€¼ä½ç½®
                positions[i*3] = p.current.x;
                positions[i*3+1] = p.current.y;
                positions[i*3+2] = p.current.z;

                // é¢œè‰²æ’å€¼
                colors[i*3] += (p.targetColor.r - colors[i*3]) * 0.1;
                colors[i*3+1] += (p.targetColor.g - colors[i*3+1]) * 0.1;
                colors[i*3+2] += (p.targetColor.b - colors[i*3+2]) * 0.1;

                // å¤§å°å˜åŒ– (è¢«å¹ç­æ—¶å˜å°)
                if (p.type === 'flame' && blowInfluence > 0.1) {
                    sizes[i] = Math.max(0, 1.5 * (1 - blowInfluence)); 
                } else {
                    sizes[i] = 1.0 + Math.sin(time + i) * 0.3;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;

            // æ•´ä½“æ—‹è½¬
            if (currentState === STATE.CAKE || currentState === STATE.BLOWING) {
                particleSystem.rotation.y = Math.sin(time * 0.2) * 0.2; // è½»è½»æ‘‡æ‘†
            } else if (currentState === STATE.CELEBRATION) {
                particleSystem.rotation.y += 0.005;
            }
        }

        /* --- 4. æµç¨‹æ§åˆ¶ (Story) --- */
        
        // å€’æ•°
        function startSequence() {
            if (currentState !== STATE.IDLE) return;
            currentState = STATE.COUNTDOWN;
            
            let count = 3;
            statusText.innerText = "æ‰‹åŠ¿æ£€æµ‹æˆåŠŸï¼Œå€’æ•°ä¸­...";
            statusDot.className = "inline-block w-3 h-3 rounded-full bg-green-500 mr-2";
            
            const timer = setInterval(() => {
                instructionText.innerText = count;
                subInstruction.innerText = count === 1 ? "Make a Wish!" : "";
                transitionTo('text', count.toString());
                
                count--;
                if (count < 0) {
                    clearInterval(timer);
                    showCake();
                }
            }, 1200);
        }

        // æ˜¾ç¤ºè›‹ç³•
        function showCake() {
            currentState = STATE.BLOWING;
            transitionTo('cake');
            
            instructionText.innerText = "Happy Birthday!";
            instructionText.className = "text-4xl md:text-6xl font-bold text-pink-300 drop-shadow-lg";
            subInstruction.innerText = "é è¿‘éº¦å…‹é£ï¼Œå¹ç­èœ¡çƒ› ğŸ‚";
            statusText.innerText = "è¯·å¹æ°”...";
            
            // æ˜¾ç¤ºå¹æ°”ä»ªè¡¨ç›˜
            blowMeterContainer.style.opacity = '1';
        }

        // å¹ç­æˆåŠŸ
        function successCelebration() {
            currentState = STATE.CELEBRATION;
            statusText.innerText = "æ„¿æœ›æˆçœŸï¼";
            blowMeterContainer.style.opacity = '0';
            
            // ç²’å­çˆ†ç‚¸æ•ˆæœ
            particlesData.forEach(p => {
                p.type = 'bg';
                p.targetColor = new THREE.Color().setHSL(Math.random(), 1, 0.5); // å½©è‰²
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 100;
                p.target.set(r*Math.cos(angle), (Math.random()-0.5)*100, r*Math.sin(angle));
            });

            instructionText.innerText = "ğŸ‰";
            subInstruction.innerText = "";

            // å»¶è¿Ÿå¼¹å‡ºæŒ‰é’®
            setTimeout(() => {
                surpriseLayer.classList.remove('hidden');
                revealBtn.classList.remove('hidden');
            }, 1000);
        }

        /* --- 5. äº¤äº’é€»è¾‘ --- */

        // éº¦å…‹é£æ£€æµ‹
        function initAudio() {
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                analyser.fftSize = 256;
                checkAudio();
            }).catch(e => {
                console.warn("éº¦å…‹é£æƒé™è¢«æ‹’ç»", e);
                statusText.innerText = "éº¦å…‹é£ä¸å¯ç”¨ï¼Œç‚¹å‡»å±å¹•è·³è¿‡";
                // å¤‡ç”¨æ–¹æ¡ˆï¼šç‚¹å‡»å±å¹•ä¹Ÿèƒ½å¹ç­
                document.addEventListener('click', () => {
                    if(currentState === STATE.BLOWING) {
                        blowProgress += 10;
                    }
                });
            });
        }

        function checkAudio() {
            requestAnimationFrame(checkAudio);
            if (currentState !== STATE.BLOWING || !analyser) return;

            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);

            // ç®€å•çš„éŸ³é‡è®¡ç®—
            let sum = 0;
            for(let i=0; i<data.length; i++) sum += data[i];
            const avg = sum / data.length;

            if (avg > CONFIG.blowThreshold) {
                isBlowing = true;
                blowProgress += 1.5; // å¢åŠ è¿›åº¦
            } else {
                isBlowing = false;
                blowProgress -= 0.5; // ç¼“æ…¢å›è½
            }

            // é’³åˆ¶è¿›åº¦èŒƒå›´
            blowProgress = Math.max(0, Math.min(100, blowProgress));

            // æ›´æ–° UI
            blowMeterBar.style.width = blowProgress + '%';
            
            if (blowProgress >= 100) {
                successCelebration();
            }
        }

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-overlay').style.display = 'none';
            uiLayer.style.display = 'flex';
            bgm.volume = 0.5;
            bgm.play().catch(e => console.log("Auto-play blocked"));
            
            initThree();
            initAudio();
            initCamera();
            render();
        });

        // æƒŠå–œæŒ‰é’®é€»è¾‘
        revealBtn.addEventListener('click', () => {
            // 1. éšè—æŒ‰é’®
            revealBtn.style.display = 'none'; 
            
            // 2. æ˜¾ç¤ºå†…å®¹
            surpriseContent.classList.remove('hidden');
            surpriseContent.classList.add('pop-in');
        });

        document.getElementById('close-surprise-btn').addEventListener('click', () => {
            surpriseContent.classList.add('hidden');
            revealBtn.style.display = 'block'; // é‡æ–°æ˜¾ç¤ºæŒ‰é’®
        });
        
        document.getElementById('music-btn').addEventListener('click', () => {
            if (bgm.paused) bgm.play();
            else bgm.pause();
        });

        /* --- 6. MediaPipe Setup --- */
        function initCamera() {
            const video = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                // å¦‚æœæ£€æµ‹åˆ°æ‰‹ï¼Œå¹¶ä¸”å¤„äºç­‰å¾…çŠ¶æ€
                if (results.multiHandLandmarks.length > 0 && currentState === STATE.IDLE) {
                    startSequence();
                }
                
                // ç»˜åˆ¶è°ƒè¯•å›¾
                const canvas = document.getElementById('output_canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // ä»…ç»˜åˆ¶ç®€å•çš„éª¨æ¶
                if(results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#ff69b4', lineWidth: 2});
                    }
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        function render() {
            requestAnimationFrame(render);
            updateParticles();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>