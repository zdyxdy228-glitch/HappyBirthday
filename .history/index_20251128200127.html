<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥å¿«ä¹ - äº’åŠ¨ç²’å­é­”æ³• (åŠ¨æ€å¢å¼ºç‰ˆ)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; -webkit-user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 2rem; box-sizing: border-box; }
        .interactive-element { pointer-events: auto; }
        .input_video { display: none; }
        .glass-panel { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 1rem; }
        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 50; display: flex; justify-content: center; align-items: center; pointer-events: auto; }
        .pop-in { animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn { 0% { opacity: 0; transform: scale(0.5) translateY(50px); } 100% { opacity: 1; transform: scale(1) translateY(0); } }
    </style>
</head>
<body>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <!-- å¯åŠ¨é®ç½© -->
    <div id="start-overlay">
        <div class="text-center max-w-md p-8 glass-panel">
            <h1 class="text-4xl font-bold mb-4 text-pink-400">âœ¨ ç²’å­é­”æ³•ç”Ÿæ—¥ä¼š âœ¨</h1>
            <p class="mb-6 text-gray-300">
                è¯·å…è®¸è®¿é—®<b>æ‘„åƒå¤´</b>ï¼ˆæ•æ‰æ‰‹åŠ¿ï¼‰å’Œ<b>éº¦å…‹é£</b>ï¼ˆå¹èœ¡çƒ›ï¼‰ã€‚<br>
                ä½“éªŒä¸“å±äºä½ çš„ 3D äº’åŠ¨æ—¶åˆ»ã€‚
            </p>
            <button id="start-btn" class="px-8 py-3 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full font-bold text-lg hover:scale-105 transition transform shadow-lg shadow-pink-500/50">
                å¼€å§‹ä½“éªŒ
            </button>
        </div>
    </div>

    <!-- ä¸» UI å±‚ -->
    <div id="ui-layer" style="display: none;">
        <div class="flex justify-between items-start">
            <div class="glass-panel p-4 interactive-element">
                <h2 class="text-xl font-bold text-pink-300 mb-1">Status</h2>
                <div id="status-text" class="text-sm text-white font-mono">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
            </div>
            
            <div class="glass-panel p-3 flex gap-4 interactive-element">
                <div class="flex flex-col items-center">
                    <label class="text-xs text-gray-400 mb-1">ç²’å­é¢œè‰²</label>
                    <input type="color" id="color-picker" value="#ff69b4" class="w-8 h-8 rounded cursor-pointer border-none bg-transparent">
                </div>
                <button id="fullscreen-btn" class="p-2 hover:bg-white/10 rounded transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                </button>
            </div>
        </div>

        <div id="center-instruction" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none w-full z-0">
            <h2 id="instruction-text" class="text-4xl md:text-6xl font-bold text-white drop-shadow-[0_0_10px_rgba(255,105,180,0.8)] transition-all duration-500">
                ğŸ‘‹ è¯·ä¸¾èµ·åŒæ‰‹
            </h2>
            <p id="sub-instruction" class="mt-4 text-xl text-pink-200 opacity-80">è®©é­”æ³•å¼€å§‹</p>
        </div>

        <div id="surprise-layer" class="absolute inset-0 flex flex-col justify-center items-center z-20 hidden pointer-events-none">
            <button id="reveal-btn" class="interactive-element hidden px-10 py-5 bg-white text-pink-600 rounded-full font-bold text-2xl shadow-[0_0_30px_rgba(255,105,180,0.6)] hover:scale-110 transition transform animate-bounce">
                ğŸ ç‚¹å‡»æ­æ™“æƒŠå–œ
            </button>

            <div id="surprise-content" class="interactive-element hidden max-w-md w-full mx-4 glass-panel p-6 transform transition-all duration-500 relative">
                <div class="w-full h-64 bg-gray-800 rounded-lg mb-6 overflow-hidden border-2 border-pink-300 shadow-lg relative group">
                    <img src="https://images.unsplash.com/photo-1549465220-1a8b9238cd48?q=80&w=800&auto=format&fit=crop" class="w-full h-full object-cover transition duration-500 group-hover:scale-110" alt="Birthday Gift">
                    <div class="absolute bottom-0 left-0 w-full bg-black/60 text-white text-xs p-2 text-center opacity-70">
                        (è¯·æ›¿æ¢ä¸ºä½ çš„ç…§ç‰‡)
                    </div>
                </div>
                
                <h3 class="text-2xl font-bold text-pink-300 mb-4 text-center">è‡´äº²çˆ±çš„ä½ </h3>
                <div class="text-white text-center leading-relaxed space-y-2 font-light">
                    <p>ç”Ÿæ—¥å¿«ä¹ï¼ğŸ‚</p>
                    <p>æ„¿ä½ åœ¨è¿™ç‰¹åˆ«çš„ä¸€å¤©é‡Œï¼Œ</p>
                    <p>æ‰€æœ‰çš„æ¢¦æƒ³éƒ½èƒ½åƒè¿™æ¼«å¤©ç¹æ˜Ÿä¸€æ ·é—ªè€€ã€‚</p>
                    <p>ä¿æŒçƒ­çˆ±ï¼Œå¥”èµ´å±±æµ·ï¼</p>
                    <p class="text-pink-400 font-bold mt-4">Happy 23rd Birthday!</p>
                </div>
                <button id="close-surprise-btn" class="absolute top-2 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
        </div>

        <div class="flex justify-center mb-8">
            <div id="camera-preview" class="w-32 h-24 glass-panel overflow-hidden relative interactive-element hidden md:block">
                 <canvas id="output_canvas" width="160" height="120" class="w-full h-full object-cover"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- ç‰©ç†å‚æ•°é…ç½® ---
        const PHYSICS = {
            friction: 0.90,       // æ‘©æ“¦åŠ›
            springStrength: 0.05, // å¼¹åŠ›ï¼šå›åˆ°ç›®æ ‡ä½ç½®çš„æ‹‰åŠ›
            explosionForce: 2.5   // çˆ†ç‚¸åŠ›åº¦
        };

        const STATE = { IDLE: 0, COUNTDOWN: 1, CAKE: 2, BLOWING: 3, CELEBRATION: 4 };
        let currentState = STATE.IDLE;
        
        let particleSystem, scene, camera, renderer;
        let particlesData = [];
        const PARTICLE_COUNT = 4500; 
        let baseColor = new THREE.Color(0xff69b4); 
        let time = 0;
        
        let handDetected = false;
        // æ–°å¢ï¼šè®°å½•æ‰‹éƒ¨ä½ç½®ç”¨äºç²’å­äº’åŠ¨
        let handPosition = new THREE.Vector3(0, 0, 0);
        let blowVolume = 0;
        let mouse = new THREE.Vector2();
        let audioContext, analyser, microphone;

        // Dom Elements
        const statusText = document.getElementById('status-text');
        const instructionText = document.getElementById('instruction-text');
        const subInstruction = document.getElementById('sub-instruction');
        const colorPicker = document.getElementById('color-picker');
        const surpriseLayer = document.getElementById('surprise-layer');
        const revealBtn = document.getElementById('reveal-btn');
        const surpriseContent = document.getElementById('surprise-content');
        const closeSurpriseBtn = document.getElementById('close-surprise-btn');

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            container.appendChild(renderer.domElement);

            createParticles();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            colorPicker.addEventListener('input', (e) => baseColor.set(e.target.value));
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            particlesData = [];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // åˆå§‹åˆ†å¸ƒèŒƒå›´
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 50;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                colors[i * 3] = baseColor.r;
                colors[i * 3 + 1] = baseColor.g;
                colors[i * 3 + 2] = baseColor.b;
                sizes[i] = Math.random() * 2;

                particlesData.push({
                    current: new THREE.Vector3(x, y, z),
                    target: new THREE.Vector3(x, y, z),
                    initialPos: new THREE.Vector3(x, y, z), // è®°å½•åˆå§‹ä½ç½®ç”¨äºIDLEæ¼‚æµ®
                    velocity: new THREE.Vector3(0, 0, 0),
                    noiseOffset: Math.random() * 1000, 
                    isFlame: false,
                    targetColor: baseColor.clone()
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                map: createCircleTexture(),
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function getPointsFromText(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200; canvas.height = 200;
            ctx.font = 'bold 100px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);
            const data = ctx.getImageData(0, 0, 200, 200).data;
            const points = [];
            for (let y = 0; y < 200; y += 3) {
                for (let x = 0; x < 200; x += 3) {
                    if (data[(y * 200 + x) * 4 + 3] > 128) {
                        points.push(new THREE.Vector3((x - 100) / 4, -(y - 100) / 4, 0));
                    }
                }
            }
            return points;
        }

        function getCakePoints() {
            const points = [];
            const layers = [
                { r: 14, h: 6, y: -10, color: new THREE.Color(0xFFB6C1) },
                { r: 10, h: 5, y: -4,  color: new THREE.Color(0xFF69B4) },
            ];
            layers.forEach(layer => {
                for(let i=0; i<800; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = layer.r * (0.95 + Math.random() * 0.05); 
                    points.push({
                        vec: new THREE.Vector3(r * Math.cos(theta), layer.y + Math.random()*layer.h, r * Math.sin(theta)),
                        type: 'cake', color: layer.color
                    });
                }
            });
            const candleY = layers[1].y + layers[1].h;
            for(let i=0; i<300; i++) {
                const theta = Math.random() * Math.PI * 2; const r = Math.random() * 0.8; const h = Math.random() * 8;
                let c = new THREE.Color(0xEEEEEE);
                if (Math.sin(h * 2 + theta) > 0.5) c = new THREE.Color(0xFF0000);
                points.push({ vec: new THREE.Vector3(r*Math.cos(theta), candleY+h, r*Math.sin(theta)), type: 'candle', color: c });
            }
            for(let i=0; i<400; i++) {
                const u = Math.random(); const theta = Math.random() * Math.PI * 2;
                const h = u * 5; const r = (1 - u) * 1.5 * Math.sqrt(Math.random()); 
                const color = new THREE.Color();
                if (u < 0.2) color.setHex(0x0000FF); else if (u < 0.6) color.setHex(0xFFA500); else color.setHex(0xFF4500);
                points.push({ vec: new THREE.Vector3(r*Math.cos(theta), candleY+8+h, r*Math.sin(theta)), type: 'flame', color: color });
            }
            return points;
        }

        function setTargetShape(shapeType, param) {
            let targets = [];
            
            if (shapeType === 'text') {
                targets = getPointsFromText(param);
                particlesData.forEach((p, i) => {
                    p.isFlame = false;
                    p.targetColor = baseColor;
                    if (i < targets.length) {
                        p.target.copy(targets[i]).multiplyScalar(2.5);
                    } else {
                        const theta = Math.random() * Math.PI * 2;
                        const r = 30 + Math.random() * 10;
                        p.target.set(r * Math.cos(theta), (Math.random()-0.5)*40, r * Math.sin(theta));
                    }
                    p.velocity.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(PHYSICS.explosionForce);
                });
            } else if (shapeType === 'cake') {
                const cakePoints = getCakePoints();
                particlesData.forEach((p, i) => {
                    if (i < cakePoints.length) {
                        p.target.copy(cakePoints[i].vec);
                        p.isFlame = (cakePoints[i].type === 'flame');
                        if (cakePoints[i].color) p.targetColor = cakePoints[i].color;
                    } else {
                        const theta = Math.random() * Math.PI * 2;
                        const r = 25 + Math.random() * 20;
                        p.target.set(r * Math.cos(theta), -15, r * Math.sin(theta));
                        p.isFlame = false;
                        p.targetColor = new THREE.Color(0x333333);
                    }
                    p.velocity.add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5));
                });
            } else if (shapeType === 'explode') {
                particlesData.forEach(p => {
                    p.isFlame = false;
                    p.target.set((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*100);
                    p.targetColor = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
                    p.velocity.set(Math.random()-0.5, 1, Math.random()-0.5).multiplyScalar(2); 
                });
            }
        }

        // --- æ ¸å¿ƒæ›´æ–°é€»è¾‘ï¼šå¢åŠ æ‰‹éƒ¨äº’åŠ¨ä¸å€’æ•°æŠ–åŠ¨ ---
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            time += 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particlesData[i];
                
                // 1. å¾…æœºçŠ¶æ€ (IDLE) çš„ç‰¹æ®Šå¤„ç†
                if (currentState === STATE.IDLE) {
                    // è®©ç²’å­åšå‘¼å¸å¼æ¼‚æµ®
                    const floatScale = 1 + Math.sin(time * 0.5 + p.noiseOffset) * 0.1;
                    const baseX = p.initialPos.x * floatScale;
                    const baseY = p.initialPos.y * floatScale;
                    const baseZ = p.initialPos.z * floatScale;
                    
                    // é»˜è®¤ç›®æ ‡æ˜¯æ¼‚æµ®ä½ç½®
                    p.target.set(baseX, baseY, baseZ);

                    // âœ‹ æ‰‹éƒ¨å¸å¼•é€»è¾‘
                    if (handDetected) {
                        // è®¡ç®—ç²’å­åˆ°æ‰‹çš„è·ç¦»
                        const dist = p.current.distanceTo(handPosition);
                        // å¦‚æœè·ç¦»å°äºä¸€å®šèŒƒå›´ï¼ˆä¾‹å¦‚40å•ä½ï¼‰ï¼Œå—åˆ°å¸å¼•åŠ›
                        if (dist < 40) {
                            // å¸å¼•åŠ›å‘é‡
                            const attraction = new THREE.Vector3().subVectors(handPosition, p.current).normalize().multiplyScalar(0.8);
                            p.velocity.add(attraction);
                            
                            // åŠ ä¸€ç‚¹æ—‹è½¬æ‰°åŠ¨ï¼Œå½¢æˆæ¼©æ¶¡æ„Ÿ
                            p.velocity.x += Math.sin(time * 5 + p.noiseOffset) * 0.1;
                            p.velocity.y += Math.cos(time * 5 + p.noiseOffset) * 0.1;
                        }
                    }
                }

                // 2. å€’æ•°çŠ¶æ€ (COUNTDOWN) çš„ç‰¹æ®Šå¤„ç†
                if (currentState === STATE.COUNTDOWN) {
                    // è®©ç»„æˆçš„æ•°å­—ç²’å­ä¿æŒæ´»è·ƒéœ‡åŠ¨ï¼Œè€Œä¸æ˜¯é™æ­¢
                    const jitterForce = 0.05;
                    p.velocity.x += (Math.random() - 0.5) * jitterForce;
                    p.velocity.y += (Math.random() - 0.5) * jitterForce;
                    p.velocity.z += (Math.random() - 0.5) * jitterForce;
                }

                // --- ç‰©ç†å¼•æ“é€šç”¨è®¡ç®— ---
                
                const dx = p.target.x - p.current.x;
                const dy = p.target.y - p.current.y;
                const dz = p.target.z - p.current.z;

                const ax = dx * PHYSICS.springStrength;
                const ay = dy * PHYSICS.springStrength;
                const az = dz * PHYSICS.springStrength;

                const spiralVar = Math.sin(time * 2 + p.noiseOffset) * 0.05;
                
                p.velocity.x += ax + spiralVar;
                p.velocity.y += ay + spiralVar;
                p.velocity.z += az;

                p.velocity.multiplyScalar(PHYSICS.friction);

                if (p.isFlame && currentState === STATE.BLOWING) {
                    const jitter = 1 + (blowVolume * 0.2); 
                    p.velocity.x += (Math.random() - 0.5) * 0.2 * jitter;
                    p.velocity.y += Math.random() * 0.2 * jitter;
                    if (blowVolume > 50) {
                        p.velocity.y += 0.5;
                        p.targetColor.lerp(new THREE.Color(0x333333), 0.1);
                    }
                }

                p.current.add(p.velocity);

                positions[i * 3] = p.current.x;
                positions[i * 3 + 1] = p.current.y;
                positions[i * 3 + 2] = p.current.z;
                
                let desiredColor = (currentState >= STATE.CAKE) ? p.targetColor : baseColor;
                // å€’æ•°æ—¶ç¨å¾®äº®ä¸€ç‚¹
                if (currentState === STATE.COUNTDOWN) {
                    desiredColor = new THREE.Color(0xffb6c1); // æµ…ç²‰è‰²
                }
                
                colors[i * 3] += (desiredColor.r - colors[i * 3]) * 0.08;
                colors[i * 3 + 1] += (desiredColor.g - colors[i * 3 + 1]) * 0.08;
                colors[i * 3 + 2] += (desiredColor.b - colors[i * 3 + 2]) * 0.08;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;

            if (currentState === STATE.CAKE || currentState === STATE.BLOWING) {
                particleSystem.rotation.y = Math.sin(time * 0.1) * 0.1;
            } else {
                particleSystem.rotation.y += 0.001;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            checkAudioBlow();
            renderer.render(scene, camera);
        }

        function startCountdown() {
            if (currentState !== STATE.IDLE) return;
            // å¢åŠ ä¸€ç‚¹å»¶è¿Ÿï¼Œè®©ç”¨æˆ·å…ˆçœ‹åˆ°ç²’å­å‘æ‰‹èšæ‹¢çš„æ•ˆæœ
            setTimeout(() => {
                currentState = STATE.COUNTDOWN;
                statusText.innerText = "å€’æ•°å¼€å§‹...";
                instructionText.innerText = ""; 
                subInstruction.innerText = "Make a Wish";
                setTargetShape('text', "3");

                setTimeout(() => { setTargetShape('text', "2"); }, 1500);
                setTimeout(() => { setTargetShape('text', "1"); }, 3000);
                setTimeout(() => { startCakePhase(); }, 4500);
            }, 1000); // å»¶è¿Ÿ1ç§’è¿›å…¥å€’æ•°
        }

        function startCakePhase() {
            currentState = STATE.BLOWING; 
            blowVolume = 0; 
            setTargetShape('cake');
            
            setTimeout(() => {
                instructionText.innerText = "23å²å¥³ç”Ÿï¼Œç”Ÿæ—¥å¿«ä¹ï¼";
                instructionText.className = "text-3xl md:text-5xl font-bold text-pink-300 drop-shadow-lg";
                subInstruction.innerText = "è¯·é è¿‘éº¦å…‹é£ï¼Œç”¨åŠ›å¹ç­èœ¡çƒ› ğŸ‚ğŸ’¨";
                statusText.innerText = "æ£€æµ‹å¹æ°”ä¸­...";
            }, 1000);
        }

        function startCelebration() {
            currentState = STATE.CELEBRATION;
            statusText.innerText = "ğŸ‰ ç”Ÿæ—¥å¿«ä¹ï¼ ğŸ‰";
            instructionText.innerText = "æ„¿æœ›æˆçœŸï¼âœ¨";
            subInstruction.innerText = "";
            setTargetShape('explode');

            setTimeout(() => {
                surpriseLayer.classList.remove('hidden');
                surpriseLayer.classList.remove('pointer-events-none'); 
                revealBtn.classList.remove('hidden');
            }, 3000);
        }

        revealBtn.addEventListener('click', () => {
            revealBtn.classList.add('hidden');
            surpriseContent.classList.remove('hidden');
            surpriseContent.classList.add('pop-in');
        });
        closeSurpriseBtn.addEventListener('click', () => surpriseLayer.classList.add('hidden'));

        function initAudio() {
            if (!navigator.mediaDevices.getUserMedia) return;
            navigator.mediaDevices.getUserMedia({ audio: true }).then(function(stream) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                analyser.fftSize = 256;
            }).catch(e => statusText.innerText = "éº¦å…‹é£è®¿é—®å¤±è´¥");
        }

        function checkAudioBlow() {
            if (currentState !== STATE.BLOWING || !analyser) return;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            let sum = 0; for(let i=0; i<dataArray.length/2; i++) sum += dataArray[i];
            const average = sum / (dataArray.length/2);
            if (average > 40) {
                blowVolume++;
                if (blowVolume > 100) startCelebration();
            } else {
                blowVolume = Math.max(0, blowVolume - 0.5);
            }
        }

        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                
                // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒä½ç½® (ç´¢å¼•9æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œæ¥è¿‘æ‰‹å¿ƒ)
                // åæ ‡å½’ä¸€åŒ–(0-1)ï¼Œéœ€è¦æ˜ å°„åˆ°3Dä¸–ç•Œåæ ‡ (å¤§æ¦‚ -50 åˆ° 50)
                const hand = results.multiHandLandmarks[0];
                const palmBase = hand[9]; 
                
                // ç®€å•çš„æ˜ å°„ï¼šMediaPipe x æ˜¯ 0(å·¦)-1(å³)ï¼Œy æ˜¯ 0(ä¸Š)-1(ä¸‹)
                // Three.js x æ˜¯ è´Ÿ(å·¦)-æ­£(å³)ï¼Œy æ˜¯ æ­£(ä¸Š)-è´Ÿ(ä¸‹)
                // ä¹˜ä»¥ä¸€ä¸ªç³»æ•°æ¥é€‚é…å±å¹•
                const targetX = (0.5 - palmBase.x) * 150; // åè½¬Xè½´å¹¶ç¼©æ”¾
                const targetY = (0.5 - palmBase.y) * 100; // åè½¬Yè½´å¹¶ç¼©æ”¾
                
                // å¹³æ»‘æ›´æ–°æ‰‹éƒ¨ä½ç½®ï¼Œé¿å…è·³å˜
                handPosition.lerp(new THREE.Vector3(targetX, targetY, 0), 0.1);

                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#ff69b4', lineWidth: 2});
                }
                
                if (currentState === STATE.IDLE) {
                    statusText.innerText = "æ£€æµ‹åˆ°åŒæ‰‹ï¼ç²’å­æ­£åœ¨æ±‡èš...";
                    // é€»è¾‘æ”¹ä¸ºï¼šè¯†åˆ«åˆ°æ‰‹ -> è§¦å‘ startCountdown (å†…éƒ¨å·²åŠ å»¶è¿Ÿï¼Œç»™ç²’å­ä¸€ç‚¹æ±‡èšæ—¶é—´)
                    startCountdown();
                }
            } else {
                // å¦‚æœæ‰‹ç§»å¼€äº†ï¼Œé‡ç½®çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
                // handDetected = false; 
                // ä¿æŒ true å¯ä»¥è®©ç²’å­ä¸ç«‹åˆ»æ•£å¼€ï¼Œæˆ–è€…è®¾ä¸º false è®©ç²’å­é£˜èµ°
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            initAudio();
            initThree();
            animate();
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
    </script>
</body>
</html>